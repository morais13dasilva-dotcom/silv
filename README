1) Вариант 1. Жадный алгоритм для вершинного покрытия
Задача: реализовать жадный 2-аппроксимационный алгоритм для задачи о вершинном покрытии. Входные данные представляют собой граф, заданный списком ребер. Необходимо найти множество вершин, таких что каждое ребро имеет хотя бы один конец в этом множестве.

2) Анализ алгоритма по шагам

Шаг 1: Инициализация

cover = set() 
remaining_edges = edges.copy()


· Создается пустое множество для вершинного покрытия
· Создается копия списка ребер для обработки

Шаг 2: Основной цикл

while remaining_edges:


· Цикл выполняется, пока есть непокрытые ребра

Шаг 3: Выбор ребра

u, v = remaining_edges[0]


· Берется первое ребро из списка (0,1)

Шаг 4: Добавление вершин в покрытие

cover.add(u)
cover.add(v)


· Вершины 0 и 1 добавляются в покрытие

Шаг 5: Удаление покрытых ребер

remaining_edges = [edge for edge in remaining_edges 
                  if u not in edge and v not in edge]


· Удаляются все ребра, инцидентные вершинам 0 и 1
· После первой итерации: удаляются ребра (0,1) и (9,0)

Последовательность выполнения:

1. Итерация 1: берется ребро (0,1), добавляются вершины 0,1
2. Итерация 2: берется ребро (1,2), добавляются вершины 1,2 (1 уже есть)
3. Итерация 3: берется ребро (2,3), добавляются вершины 2,3 (2 уже есть)
4. ... и так далее, пока не будут покрыты все вершины

3) Временная сложность

Временная сложность: O(|E|²)

4) Пояснение временной сложности

Анализ сложности по шагам:

1. Инициализация: O(|E|) - копирование списка ребер
2. Внешний цикл while: выполняется O(|E|) раз в худшем случае
   · На каждой итерации удаляется как минимум одно ребро
3. Внутренняя операция фильтрации:
  
   remaining_edges = [edge for edge in remaining_edges 
                     if u not in edge and v not in edge]
   

   · Эта операция имеет сложность O(|E|) на каждой итерации
   · Проходит по всем оставшимся ребрам и проверяет условие

Итоговая сложность: O(|E|) × O(|E|) = O(|E|²)

В худшем случае (когда граф представляет собой цикл, как в нашем примере), алгоритм будет работать за квадратичное время от количества ребер.

5) Ответ на контрольный вопрос

Определение приближенных алгоритмов:

Приближенный алгоритм - это алгоритм, который находит не точное, но близкое к оптимальному решение сложной вычислительной задачи за полиномиальное время.

Основная цель в решении NP-сложных задач:

1. Практическая применимость: Для NP-сложных задач не существует известных эффективных точных алгоритмов. Приближенные алгоритмы позволяют находить "достаточно хорошие" решения за разумное время.
2. Гарантии качества: Многие приближенные алгоритмы предоставляют гарантии относительно того, насколько найденное решение отличается от оптимального. Например, жадный алгоритм для вершинного покрытия гарантирует, что размер найденного покрытия не более чем в 2 раза превышает размер минимального покрытия.
3. Компромисс между точностью и временем: Приближенные алгоритмы предлагают баланс между качеством решения и вычислительной сложностью, что делает их практичными для решения реальных задач больших размеров.
4. Универсальность: Они могут применяться к широкому классу оптимизационных задач, где поиск точного решения требует экспоненциального времени.
